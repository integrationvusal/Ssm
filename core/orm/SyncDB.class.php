<?php	class SyncDB {				private static $fieldsWithoutLength = Array('blob','date');		private static $fieldsWithoutDefaultValue = Array('blob','date');		private static $fieldsSQL = Array(			'id' => '`id` int(32) NOT NULL AUTO_INCREMENT',			'r_id' => '`r_id` int(32) NOT NULL',			'lang_id' => '`lang_id` char(2) NOT NULL',			'deleted' => '`deleted` int(1) NOT NULL DEFAULT 0',		);				public static function synchronize($classInfo, $returnSql = false) {			$tableName = $classInfo['className']::getTableName($classInfo['className']);			if (self::tableExists($tableName)) return self::alterTable($classInfo, $returnSql);			else return self::createTable($classInfo, $returnSql);		}				public static function synchronizeAll() {			$classesToSynchronize = Application::$settings['classes_to_synchronize'];			foreach ($classesToSynchronize as $class) {				self::synchronize($class::getClassInfo());			}		}				/*			Идея: для начала проверяем наличие всех полей из таблицы в свойствах класса,			те свойства которые существую как поле таблицы, храним в массиве $classVarsExist, а также запоминаем команду alter column для этого поля таблицы,			потом проходим по свойствам класса, если свойство не находится в массиве $classVarsExist, значит надо выполнить команду add column.			Если поле таблицы не находится среди свойств класса для него выполняем команду drop.			Эта же идея используется и при синхронизации самих таблиц.		*/		private static function checkTableSynchronized($classInfo) {			$class = $classInfo['className'];			$tableName = $class::getTableName($class);						// get table fields as array from db			$tableFields = self::getTableFields($tableName);						$classVars = $classInfo['classVars'];						$queries = Array();						// названия переменных, которые уже существуют			$classVarsExist = Array();						$tmpObject = new $class();						// table to class			foreach ($tableFields as $f) {				if (in_array($f['Field'], $classVars)) {					if (self::isFieldIdentity($f, $tmpObject->$f['Field']) === false) {						$queries[] = Array('1',$f['Field']);					}					$classVarsExist[] = $f['Field'];				} else {					$queries[] = Array('0',$f['Field']);				}			}						// class to table			foreach ($classVars as $v) {				if (!in_array($v, $classVarsExist)) {					$queries[] = Array('2',$v);				}			}						return $queries;		}				private static function createIndex($tableName, $columnName) {			//CREATE INDEX `test_index` ON `vl1_Test` (`id`)		}				private static function isFieldIdentity($field, $property) {			if (((isset($property->dbType)) && !in_array($property->dbType, self::$fieldsWithoutLength)) && ($field['Type'] !== $property->dbType . '(' . $property->dbLength . ')')) return false;			$field['Null'] = ($field['Null'] == 'YES') ? true : false;			if (isset($property->allowNull) && $property->allowNull !== $field['Null']) return false;			return true;		}				private static function getTableFields($tableName) {			return BaseModel::fQuery("DESCRIBE `".$tableName."`");		}		private static function getFieldsSql($classInfo) {			$classInfo['className']::initialize();			$fieldsSQL = Array();			$class = $classInfo['className'];			$tmpObject = new $class();			foreach ($classInfo['classVars'] as $k => $v) {				if (($v == 'id') || (($class::$multiLang) && (($v == 'r_id') || ($v == 'lang_id'))) || (in_array('deleted', $classInfo['classVars']) && ($v == 'deleted'))) {					$fieldsSQL[$v] = self::$fieldsSQL[$v];					continue;				}				$sql = '';				$sql .= '`'. $v . '`';				$sql .= ' ' . $tmpObject->$v->dbType;				if (!in_array($tmpObject->$v->dbType, self::$fieldsWithoutLength)) $sql .= '('.$tmpObject->$v->dbLength.')';				$sql .= ' ';				if (!$tmpObject->$v->allowNull) {					$sql .= ' NOT NULL ';					/*					if (($tmpObject->$v->defaultValue != 'null') && (!in_array($tmpObject->$v->dbType, self::$fieldsWithoutDefaultValue))) {						$sql .= " DEFAULT ".$tmpObject->$v->defaultValue;					}*/				}				else {					//if (!in_array($tmpObject->$v->dbType, self::$fieldsWithoutDefaultValue)) $sql .= " DEFAULT ".$tmpObject->$v->defaultValue;				}				$fieldsSQL[$v] = $sql;			}			return $fieldsSQL;		}				private static function createTable($classInfo, $returnSql = false) {			$fieldsSQL = self::getFieldsSql($classInfo);			$sql = "CREATE TABLE IF NOT EXISTS `".$classInfo['className']::getTableName($classInfo['className'])."` (" . join(",",$fieldsSQL) . ", PRIMARY KEY (`id`)) ENGINE=".$classInfo['className']::$dbEngine." DEFAULT CHARSET=utf8;";			if ($returnSql) return $sql;			return BaseModel::query($sql);		}				private static function alterTable($classInfo, $returnSql = false) {			$queries = self::checkTableSynchronized($classInfo);			$fieldsSQL = self::getFieldsSql($classInfo);			$alterTableSQL = "ALTER TABLE `".$classInfo['className']::getTableName($classInfo['className'])."`";			$columnSQL = Array();			foreach ($queries as $q) {				switch ($q[0]) {					case 0:						$columnSQL[] = $alterTableSQL . " DROP COLUMN `".$q[1]."`;";						break;					case 1:						$columnSQL[] = $alterTableSQL . " MODIFY ".$fieldsSQL[$q[1]].";";						break;					case 2:						$columnSQL[] = $alterTableSQL . " ADD ".$fieldsSQL[$q[1]].";";						break;				}			}			$errors = 0;			if ($returnSql) return $columnSQL;			foreach ($columnSQL as $q) if (!BaseModel::query($q)) $errors++;			return ($errors > 0) ? false : true;		}				private function tableToClass($tableName) {			return preg_replace(Application::$dbSettings['prefix'] . '_','',$tableName);		}				private static function getDBTables() {			$tables = Array();			$result = BaseModel::fQuery("SHOW TABLES");			$fieldTitle = 'Tables_in_' . Application::$dbSettings['name'];			foreach ($result as $r) {				$tables[] = $r[$fieldTitle];			}			return $tables;		}				private static function tableExists($tableName) {			$r = BaseModel::fQuery("SHOW TABLES LIKE '".$tableName."'");			return count($r);		}			}?>